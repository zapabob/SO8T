#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
マルウェア検知エージェント
- プロセス監視、ネットワーク監視
- 異常行動検知（SO8Tベース）
- 危険度判定（ESCALATE優先）
"""

import os
import sys
import psutil
import socket
import json
import hashlib
import sqlite3
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict
import threading
import time


@dataclass
class ProcessInfo:
    """プロセス情報"""
    pid: int
    name: str
    exe: str
    cmdline: str
    cpu_percent: float
    memory_mb: float
    connections: int
    create_time: float
    risk_score: float = 0.0


@dataclass
class NetworkConnection:
    """ネットワーク接続情報"""
    pid: int
    local_addr: str
    local_port: int
    remote_addr: str
    remote_port: int
    status: str
    protocol: str


@dataclass
class AnomalyDetection:
    """異常検知結果"""
    detection_id: str
    timestamp: str
    anomaly_type: str  # process/network/behavior
    severity: str  # low/medium/high/critical
    description: str
    evidence: Dict
    decision: str  # ALLOW/ESCALATE/DENY


class ProcessMonitor:
    """プロセス監視器"""
    
    # 疑わしいプロセス名パターン
    SUSPICIOUS_PATTERNS = [
        "mimikatz", "psexec", "ncat", "netcat", "powercat",
        "procdump", "pwdump", "hashdump", "keylogger",
        "ransomware", "cryptolocker", "trojan", "backdoor"
    ]
    
    # ホワイトリストプロセス
    WHITELIST = [
        "System", "svchost.exe", "explorer.exe", "chrome.exe",
        "python.exe", "ollama.exe", "code.exe"
    ]
    
    @classmethod
    def get_running_processes(cls) -> List[ProcessInfo]:
        """実行中プロセス取得"""
        processes = []
        
        for proc in psutil.process_iter(['pid', 'name', 'exe', 'cmdline', 'cpu_percent', 'memory_info', 'create_time']):
            try:
                info = proc.info
                
                # ネットワーク接続数
                connections = len(proc.connections())
                
                # メモリ使用量（MB）
                memory_mb = info['memory_info'].rss / (1024 * 1024) if info.get('memory_info') else 0.0
                
                proc_info = ProcessInfo(
                    pid=info['pid'],
                    name=info.get('name', ''),
                    exe=info.get('exe', ''),
                    cmdline=' '.join(info.get('cmdline', [])) if info.get('cmdline') else '',
                    cpu_percent=info.get('cpu_percent', 0.0),
                    memory_mb=memory_mb,
                    connections=connections,
                    create_time=info.get('create_time', 0.0)
                )
                
                # リスクスコア計算
                proc_info.risk_score = cls.calculate_risk_score(proc_info)
                
                processes.append(proc_info)
            
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                continue
        
        return processes
    
    @classmethod
    def calculate_risk_score(cls, proc_info: ProcessInfo) -> float:
        """
        プロセスリスクスコア計算（0.0-1.0）
        
        Args:
            proc_info: プロセス情報
        
        Returns:
            risk_score: リスクスコア
        """
        risk = 0.0
        
        # 疑わしい名前パターン
        proc_name_lower = proc_info.name.lower()
        for pattern in cls.SUSPICIOUS_PATTERNS:
            if pattern in proc_name_lower:
                risk += 0.5
        
        # ホワイトリスト（リスク低減）
        if proc_info.name in cls.WHITELIST:
            risk -= 0.3
        
        # 高CPU使用率
        if proc_info.cpu_percent > 80:
            risk += 0.2
        
        # 大量ネットワーク接続
        if proc_info.connections > 50:
            risk += 0.3
        
        # 最近作成されたプロセス（5分以内）
        if time.time() - proc_info.create_time < 300:
            risk += 0.1
        
        # コマンドライン引数に疑わしいパターン
        cmdline_lower = proc_info.cmdline.lower()
        suspicious_args = ['exec', 'invoke', 'download', 'encoded', 'bypass', 'hidden']
        for arg in suspicious_args:
            if arg in cmdline_lower:
                risk += 0.1
        
        return min(max(risk, 0.0), 1.0)


class NetworkMonitor:
    """ネットワーク監視器"""
    
    # 疑わしいポート
    SUSPICIOUS_PORTS = [
        4444,  # Metasploit default
        5555,  # Android Debug Bridge
        6666,  # IRC bot
        31337, # Back Orifice
        12345, # NetBus
    ]
    
    @classmethod
    def get_active_connections(cls) -> List[NetworkConnection]:
        """アクティブなネットワーク接続取得"""
        connections = []
        
        for conn in psutil.net_connections(kind='inet'):
            if conn.status == psutil.CONN_ESTABLISHED:
                conn_info = NetworkConnection(
                    pid=conn.pid if conn.pid else 0,
                    local_addr=conn.laddr.ip if conn.laddr else "",
                    local_port=conn.laddr.port if conn.laddr else 0,
                    remote_addr=conn.raddr.ip if conn.raddr else "",
                    remote_port=conn.raddr.port if conn.raddr else 0,
                    status=conn.status,
                    protocol="TCP" if conn.type == socket.SOCK_STREAM else "UDP"
                )
                connections.append(conn_info)
        
        return connections
    
    @classmethod
    def check_suspicious_connections(cls, connections: List[NetworkConnection]) -> List[NetworkConnection]:
        """疑わしい接続検出"""
        suspicious = []
        
        for conn in connections:
            # 疑わしいポート
            if conn.remote_port in cls.SUSPICIOUS_PORTS or conn.local_port in cls.SUSPICIOUS_PORTS:
                suspicious.append(conn)
                continue
            
            # 外部への大量接続は「ollama」または「lmstudioSDK」経由のMCPコントロール通信のみを例外とし、その他の外部接続は遮断・要注意扱いとする
            allowed_remote_hosts = [
                "127.0.0.1",    # ローカルMCP通信
                "localhost"
                # 必要に応じて閉域MCPノード追加
            ]
            allowed_mcp_ports = [
                11434,  # ollamaデフォルト
                8080    # lmstudioSDK仮定
                # 必要に応じて追加
            ]
            if conn.remote_addr not in allowed_remote_hosts or conn.remote_port not in allowed_mcp_ports:
                # ollamaやlmstudioSDK以外への外部通信は原則遮断・報告
                suspicious.append(conn)
        
        return suspicious


class MalwareDetectorAgent:
    """マルウェア検知エージェント"""
    
    def __init__(self, db_path: Path = Path("database/so8t_malware_detection.db")):
        self.db_path = db_path
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self._init_database()
        
        self.process_monitor = ProcessMonitor()
        self.network_monitor = NetworkMonitor()
        
        self.monitoring = False
        self.monitor_thread = None
    
    def _init_database(self):
        """データベース初期化"""
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()
        
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS anomaly_detections (
            detection_id TEXT PRIMARY KEY,
            timestamp TEXT NOT NULL,
            anomaly_type TEXT NOT NULL,
            severity TEXT NOT NULL,
            description TEXT NOT NULL,
            evidence TEXT,
            decision TEXT NOT NULL
        )
        """)
        
        cursor.execute("""
        CREATE INDEX IF NOT EXISTS idx_timestamp ON anomaly_detections(timestamp)
        """)
        
        cursor.execute("""
        CREATE INDEX IF NOT EXISTS idx_severity ON anomaly_detections(severity)
        """)
        
        conn.commit()
        conn.close()
    
    def log_anomaly(self, detection: AnomalyDetection):
        """異常ログ記録"""
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()
        
        cursor.execute("""
        INSERT INTO anomaly_detections 
        (detection_id, timestamp, anomaly_type, severity, description, evidence, decision)
        VALUES (?, ?, ?, ?, ?, ?, ?)
        """, (
            detection.detection_id,
            detection.timestamp,
            detection.anomaly_type,
            detection.severity,
            detection.description,
            json.dumps(detection.evidence, ensure_ascii=False),
            detection.decision
        ))
        
        conn.commit()
        conn.close()
    
    def scan_processes(self) -> List[AnomalyDetection]:
        """プロセススキャン"""
        anomalies = []
        
        processes = self.process_monitor.get_running_processes()
        
        for proc in processes:
            if proc.risk_score > 0.5:
                # 高リスクプロセス検出
                detection = AnomalyDetection(
                    detection_id=f"PROC_{proc.pid}_{datetime.now().strftime('%Y%m%d%H%M%S')}",
                    timestamp=datetime.now().isoformat(),
                    anomaly_type="process",
                    severity="high" if proc.risk_score > 0.7 else "medium",
                    description=f"疑わしいプロセス検出: {proc.name} (PID: {proc.pid})",
                    evidence={
                        "pid": proc.pid,
                        "name": proc.name,
                        "exe": proc.exe,
                        "cmdline": proc.cmdline,
                        "risk_score": proc.risk_score
                    },
                    decision="ESCALATE" if proc.risk_score > 0.7 else "ALLOW"
                )
                
                anomalies.append(detection)
                self.log_anomaly(detection)
        
        return anomalies
    
    def scan_network(self) -> List[AnomalyDetection]:
        """ネットワークスキャン"""
        anomalies = []
        
        connections = self.network_monitor.get_active_connections()
        suspicious = self.network_monitor.check_suspicious_connections(connections)
        
        for conn in suspicious:
            detection = AnomalyDetection(
                detection_id=f"NET_{conn.pid}_{datetime.now().strftime('%Y%m%d%H%M%S')}",
                timestamp=datetime.now().isoformat(),
                anomaly_type="network",
                severity="high",
                description=f"疑わしいネットワーク接続: {conn.remote_addr}:{conn.remote_port}",
                evidence={
                    "pid": conn.pid,
                    "local": f"{conn.local_addr}:{conn.local_port}",
                    "remote": f"{conn.remote_addr}:{conn.remote_port}",
                    "protocol": conn.protocol
                },
                decision="ESCALATE"
            )
            
            anomalies.append(detection)
            self.log_anomaly(detection)
        
        return anomalies
    
    def start_monitoring(self, interval: int = 60):
        """継続監視開始"""
        print(f"[START] Malware detection monitoring (interval: {interval}s)")
        
        self.monitoring = True
        
        def monitor_loop():
            while self.monitoring:
                try:
                    # プロセススキャン
                    proc_anomalies = self.scan_processes()
                    if proc_anomalies:
                        print(f"[ALERT] Detected {len(proc_anomalies)} process anomalies")
                    
                    # ネットワークスキャン
                    net_anomalies = self.scan_network()
                    if net_anomalies:
                        print(f"[ALERT] Detected {len(net_anomalies)} network anomalies")
                    
                    time.sleep(interval)
                
                except Exception as e:
                    print(f"[ERROR] Monitoring error: {e}")
                    time.sleep(interval)
        
        self.monitor_thread = threading.Thread(target=monitor_loop, daemon=True)
        self.monitor_thread.start()
    
    def stop_monitoring(self):
        """監視停止"""
        print("[STOP] Stopping malware detection monitoring")
        self.monitoring = False
        if self.monitor_thread:
            self.monitor_thread.join(timeout=5)
    
    def generate_report(self, output_path: Path = None):
        """レポート生成"""
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()
        
        cursor.execute("""
        SELECT anomaly_type, severity, COUNT(*) as count
        FROM anomaly_detections
        GROUP BY anomaly_type, severity
        """)
        
        stats = cursor.fetchall()
        conn.close()
        
        if output_path is None:
            output_path = Path("_docs") / f"{datetime.now().strftime('%Y-%m-%d')}_malware_detection_report.md"
        
        output_path.parent.mkdir(exist_ok=True)
        
        report = f"""# マルウェア検知レポート

## 検知概要
- **レポート日時**: {datetime.now().isoformat()}
- **総検知数**: {sum(row[2] for row in stats)}

## 種類別統計

| 異常タイプ | 深刻度 | 検知数 |
|----------|--------|--------|
"""
        
        for anomaly_type, severity, count in stats:
            report += f"| {anomaly_type} | {severity} | {count} |\n"
        
        report += """
## 監視項目
- プロセス監視（疑わしいプロセス検出）
- ネットワーク監視（疑わしい接続検出）
- 行動分析（異常パターン検出）

## 次のステップ
- [READY] 高リスク検知への対応
- [READY] エスカレーション処理
- [READY] 監査ログ統合
"""
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(report)
        
        print(f"[OK] Report saved to {output_path}")


def test_malware_detector():
    """テスト実行"""
    print("\n[TEST] Malware Detector Test")
    print("="*60)
    
    detector = MalwareDetectorAgent()
    
    # プロセススキャン
    print("\n[SCAN] Scanning processes...")
    proc_anomalies = detector.scan_processes()
    print(f"[OK] Found {len(proc_anomalies)} process anomalies")
    
    # ネットワークスキャン
    print("\n[SCAN] Scanning network...")
    net_anomalies = detector.scan_network()
    print(f"[OK] Found {len(net_anomalies)} network anomalies")
    
    # レポート生成
    print("\n[REPORT] Generating report...")
    detector.generate_report()
    
    print("\n[OK] Test completed")


if __name__ == "__main__":
    test_malware_detector()

